#+TITLE: Manual JAVA
* Introducción
Java es un lenguage de programación orientado a objetos, se creó en 1996 y está basado en C++, es un lenguaje que se ejecuta en una máquina virtual que interpreta (la JVM, siglas de /Java Virtual Machine/) las instrucciones compiladas a bytecode (El lenguaje de la máquina virtual)
** Estructura de un programa

#+CAPTION: Hola Mundo
#+BEGIN_SRC java :eval no-export
  //Este fichero pertecene al paquete (carpeta) curso.java.manual (curso/java/manual)
  package curso.java.manual;

  //Esto es una importación de la clase Scanner del paquete java.io
  import java.io.Scanner;

  //Esto es una clase pública que se llama HolaMundo
  public class HolaMundo {

      /*Este es el método main (principal), 
  es un método especial que servirá comom punto de entrada a la aplicación. 
  Este método es:
  - público (puede ser accedido desde cualquier clase)
  - estático (puede ser accedido sin necesidad de crear un objeto de la clase
  -  no devuelve nada (tipo void)
  - recibe como argumentos un array (matriz) de objetos de tipo String (cadena de texto)
  ,*/
      public static void main (String [] args) {
	  //Este es un objeto de la clase Scanner que se llama scan
	  //Este objeto se inicializa con la palabra reservada new y
	  //recibe como argumento System.in (Entrada del sistema)
	  Scanner scan = new Scanner(System.in);

	  /*
	    Esto es una llamada a un método, concretamente al método print(String)
	    del atributo out de la clase System, este método imprime en la pantalla
	    (consola de texto) el texto que se le pase como parámetro y continúa
	    en la misma línea.
	    Como parámetro se le pasa la cadena de texto (String) "¿Cómo te llamas?"
	    Los valores de tipo String van siempre entre comillas dobles "
	   ,*/
	  System.out.print("¿Cómo te llamas?");

	  //Este es un objeto de la clase String (cadena de texto) que se llama nombre.
	  //Este objeto se inicializa automáticamente con el valor que devuleve
	  //el método readLine() (Método sin argumentos) del objeto scan.
	  String nombre = scan.nextString();

	  /*
	    Esto es otra llamada a un método, en este caso al println del atributo
	    out de la clase System, nótese la diferencia con la llamada anterior
	    (print -- println), ese ln añadido lo que hace es saltar de línea una
	    vez haya impreso lo que le pasemos como parámetro.

	    En este caso, como parámetro se le pasa una cadena de texto (igual que antes)
	    con el valor "Hola, " a lo que le concatenamos (sumamos) el valor de 
	    la variable nombre
	   ,*/
	  System.out.println("Hola, "+nombre);
      }
  }
#+END_SRC
#+NAME: HolaMundo
#+BEGIN_SRC java :exports results :classname HolaMundo
    public class HolaMundo {

	public static void main (String [] args) {
	    System.out.print("¿Cómo te llamas? ");
	    String nombre = "Víctor";
	    System.out.print(nombre);
	    System.out.println("Hola, "+nombre);
	}
    }
#+END_SRC

* Tipos de datos
Los tipos de datos primitivos en java son los siguientes:
| tipo    | descripción                                     | clase asociada |
|---------+-------------------------------------------------+----------------|
| byte    | número entero de 8 bits (-128 a 127)            | Byte           |
| short   | número entero de 16 bits (-32768 a 32767        | Short          |
| int     | número entero de 32 bits ($-2^{32}$ a $2^{32}$) | Integer        |
| long    | número entero de 64 bits ($-2^{64}$ a $2^{64}$) | Long           |
| float   | número decimal de 32 bits                       | Float          |
| double  | número decimal de 64 bits                       | Double         |
| boolean | valor booleano o lógico (verdadero o falso)     | Boolean        |
| char    | caracter de texto (único)                       | Character      |
 

Los tipos de datos normalmente se usan en su forma primitiva (columna tipo) y se pueden asignar directamente, pero a veces es util usar métodos de su clase asociada.
* Operadores
** Asignación
El operador *=* se usa para asignar valores a variables:
#+BEGIN_SRC java :eval no-export
int a = 0;
#+END_SRC
** Aritméticos
En java se pueden realizar multitud de operaciones matemáticas con la misma precedencia que en la vida real, si se necesita modificar se pueden utilizar paréntesis, los operadores aritméticos son los siguientes:
| Operador | Descripción                      |
|----------+----------------------------------|
| *+*      | Operador de suma                 |
| *-*      | Operador de resta                |
| ***      | Operador de multiplicación       |
| */*      | Operador de división             |
| *%*      | Operador de resto de la división |

El siguiente código es una pequeña demostración de los operadores mencionados:

#+CAPTION: Aritmeticos
#+NAME: Aritmeticos
#+BEGIN_SRC java :exports both :classname Aritmeticos
class Aritmeticos {

      public static void main (String[] args) {

	  // Variable de tipo int que tendrá como valor el resultado de 1 + 2
	  int resultado = 1 + 2;
	  // El valor de resultado es 3
	  System.out.println("1 + 2 = " + resultado);
	  int resultado_original = resultado;

	  // Los operadores se pueden usar entre variables (numéricas) y números
	  // en este caso se resta 1 al valor de resultado primero y se asigna a
	  // la variable resultado después
	  resultado = resultado - 1;
	  // El valor de resultado es 2
	  System.out.println(resultado_original + " - 1 = " + resultado);
	  resultado_original = resultado;

	  // Multiplicamos el resultado por 2 y lo volvemos a asignar a la variable
	  //resultado
	  resultado = resultado * 2;
	  // El valor de resultado es 4
	  System.out.println(resultado_original + " * 2 = " + resultado);
	  resultado_original = resultado;

	  // Dividimos el resultado entre 2 y lo asignamos
	  resultado = resultado / 2;
	  // El valor de resultado es 2
	  System.out.println(resultado_original + " / 2 = " + resultado);
	  resultado_original = resultado;

	  resultado = resultado + 8;
	  // El valor de resultado es 10
	  System.out.println(resultado_original + " + 8 = " + resultado);
	  resultado_original = resultado;

	  // Dividimos el resultado entre 7 y nos quedamos con el resto, luego lo
	  // asignamos
	  resultado = resultado % 7;
	  // El valor de resultado es 3
	  System.out.println(resultado_original + " % 7 = " + resultado);
      }
  }
#+END_SRC

#+RESULTS: Aritmeticos

Como vimos anteriormente, el operador suma *+* se puede utilizar también para concatenar texto:

#+CAPTION: Concatenación
#+NAME: Concatenacion
#+BEGIN_SRC java :exports both :classname Concatenacion
class Concatenacion {
    public static void main(String[] args){
        String firstString = "Esto es";
        String secondString = " una cadena de texto concatenada.";
        String thirdString = firstString+secondString;
        System.out.println(thirdString);
    }
}
#+END_SRC
*** Operadores unarios
En java hay un tipo de operadores aritméticos que sólo se utilizan en un operando, son los operadores unarios:
| Operador | Descripción                      |
|----------+----------------------------------|
| +        | Indica un valor positivo         |
| -        | Indica un valor negativo         |
| ++       | Incrementa en 1 el valor         |
| --       | Decrementa en 1 el valor         |
| !        | Invierte el valor de un booleano |

#+CAPTION: Unarios
#+NAME: Unarios
#+BEGIN_SRC java :exports both :classname Unarios
  class Unarios {

      public static void main(String[] args) {

	  int resultado = +1;
	  // El resultado es 1
	  System.out.println(resultado);

	  resultado--;
	  // El resultado es 0
	  System.out.println(resultado);

	  resultado++;
	  // El resultado es 1
	  System.out.println(resultado);

	  resultado = -resultado;
	  // El resultado es -1
	  System.out.println(resultado);

	  boolean exito = false;
	  // false
	  System.out.println(exito);
	  // true
	  System.out.println(!exito);
      }
  }
#+END_SRC

Los operadores de incremento y decremento (*++* y *--*) actuan de manera diferente dependiendo de si se ponen delante o detrás del valor a modificar, si se usan de manera prefija ~++variable~ el valor se incrementa primero y la variable se usa después (ya incrementada), si se usa de manera postfija ~variable++~ se utilizará el valor de la variable sin incrementar y luego se incrementará:

#+CAPTION: Prefijos y Postfijos
#+NAME: PrePost
#+BEGIN_SRC java :exports both :classname PrePost
  class PrePost {
      public static void main(String[] args){
	  int i = 3;
	  i++;
	  // imprime 4
	  System.out.println(i);
	  ++i;			   
	  // imprime 5
	  System.out.println(i);
	  // imprime 6
	  System.out.println(++i);
	  // imprime 6
	  System.out.println(i++);
	  // imprime 7
	  System.out.println(i);
      }
  }
#+END_SRC
** Lógicos
Son operadores que devuelven valores lógicos (verdadero o falso)
| Operador   | Descripción              |
|------------+--------------------------|
| ==         | igual que                |
| !=         | distinto que             |
| >          | mayor que                |
| >=         | mayor o igual que        |
| <          | menor que                |
| <=         | menor o igual que        |
| &&         | Y lógico                 |
| \vert\vert | Ó lógico                 |
| instanceof | Objeto pertenece a clase |

Normalmente estos operadores se utilizarán en sentencias que requieran un valor lógico, como los condicionales o los bucles, de los que hablaremos más adelante, en este ejemplo vemos como, en base a los valores 1 y 2, que operaciones se ejecutan y cuales no:

#+NAME: Comparacion
#+CAPTION: Comparación
#+BEGIN_SRC java :exports both :classname Comparacion
  class Comparacion {

      public static void main(String[] args){
	  int valor1 = 1;
	  int valor2 = 2;
	  System.out.println ("valor1="+valor1+", valor2="+valor2);
	  if(valor1 == valor2) {
	      System.out.println("valor1 == valor2 --> " + (valor1 == valor2));
	  }
	  if (valor1 != valor2) {
	      System.out.println("valor1 != valor2 --> " + (valor1 != valor2));
	  }
	  if (valor1 > valor2) {
	      System.out.println("valor1 > valor2 --> " + (valor1 > valor2));
	  }
	  if (valor1 < valor2) {
	      System.out.println("valor1 < valor2 --> " + (valor1 < valor2));
	  }
	  if (valor1 <= valor2) {
	      System.out.println("valor1 <= valor2 --> " + (valor1 <= valor2));
	  }
      }
  }
#+END_SRC

A veces es interesante comprobar si una comprobación cumple mas de una condición o si una sentencia se ejecutará si se cumple alguna de las condiciones posibles, es en este caso que utilizaremos los operadores lógicos ~&&~ y ~||~.

#+NAME: Condicionales
#+CAPTION: Operadores Condicionales
#+BEGIN_SRC java :exports both :classname Condicionales
  class Condicionales {

      public static void main(String[] args){
	  int valor1 = 1;
	  int valor2 = 2;
	  if((valor1 == 1) && (valor2 == 2))
	      System.out.println("valor1 es 1 AND (Y) valor2 es 2");
	  if((valor1 == 1) || (valor2 == 1))
	      System.out.println("valor1 es 1 OR (O) valor2 es 1");
      }
  }
#+END_SRC

* Condicionales
En java tenemos principalmente dos estructuras condicionales, la primera es la que se compone con las sentencias ~if~ y ~else~, y la segunda es la sentencia ~switch~.

La sentencia ~if~ se escribe de la siguiente manera:
#+BEGIN_SRC java :eval no-export
if (condicion) {
    proceso;
}
#+END_SRC
Donde ~condicion~ es un valor booleano (lógico), que puede ser una variable de tipo boolean, un valor ~true~ o ~false~ directamente, aunque no tuviera mucho sentido en este caso, o el resultado de una comparación como las que acabamos de ver.

Si la condición se cumple el ~proceso~ (que puede ser un número indeterminado de sentencias) se ejecuta, si no se cumple, no se ejecuta, decimos que se produce un salto condicional.

Hay veces que queremos que si se cumple una condición se ejecute un determinado código y, si no se cumple, otro, esto lo conseguimos con la sentencia ~else~ que tiene una forma parecida al ~if~, pero en este caso no se especifica condición, sino que la condición es que no se cumpla el ~if~.

#+BEGIN_SRC java :eval no-export
if (condicion) {
    proceso;
} else {
    otroProceso;
}
#+END_SRC

Puede suceder que queramos comprobar una cosa y luego, independientemente otra, en ese caso solo tendríamos que tener un ~if~ primero y, una vez cerrado, otro con otra condición, en ese caso serían sentencias independientes y no habría ningún problema, pero podemos querer comprobar algo y, si se cumple, otra cosa después, esto lo hacemos /anidando/ sentencias ~if~ o ~else~:
#+BEGIN_SRC java :eval no-export
if (condicion1) {
    proceso1;
    if (condicion2) {
        proceso2;
    }
    proceso3;
} else {
    if (condicion3) {
        proceso4;
    }
}
#+END_SRC

Si nos fijamos en el ~else~ (aunque esto puede ocurrir en cualquier otra parte, incluido el bloque del ~if~), podemos observar que, en caso de no cumplirse la ~condicion1~, podemos tener dentro otra estructura completa de sentencias ~if~ y cada una puede tener sus respectivos ~else~ y así indefinidamente, una manera de organizar mejor esté código es utilizando la sentencia compuesta ~else if~ que nos permite hacer varias comprobaciones sin aumentar el nivel de anidación, por ejemplo:

#+NAME: Elseif
#+CAPTION: Else-If
#+BEGIN_SRC java :exports both :classname Elseif
  class Elseif {
    public static void main (String [] args) {
      int val = 10;
      if (val == 0) {
	System.out.println("val = 0");
      } else if (val == 1) {
	System.out.println("val = 1");
      } else if (val == 2) {
	System.out.println("val = 2");
      } else if (val == 3) {
	System.out.println("val = 3");
      } else if (val == 4) {
	System.out.println("val = 4");
      } else if (val == 5) {
	System.out.println("val = 5");
      } else {
	System.out.pritnln("val > 5");
      }
    }
  }
#+END_SRC

En este caso como el valor de la variable ~val~ es 10, pasaría por cada una de las condicione y, al no cumplirse, entraría por la sentencia ~else~ si hiciéramos esto anidando sentencias ~if~ y ~else~ el código se /iría/ muy a la derecha y sería más dificil de leer, pero aún tenemos otra sentencia que nos permite resolver estos problemas de una manera más elegante, la sentencia ~switch~.

El ejemplo anterior, escrito con una sentencia switch sería el siguiente:
#+CAPTION: Switch
#+NAME: Switch
#+BEGIN_SRC java :exports both :classname Switch
  class Switch {
      public static void main (String [] args) {
	int val = 10;
	switch(val) {
	case 0:
	  System.out.println("val = 0");
	  break;
	case 1:
	  System.out.println("val = 1");
	  break;
	case 2:
	  System.out.println("val = 2");
	  break;
	case 3:
	  System.out.println("val = 4");
	  break;
	case 4:
	  System.out.println("val = 4");
	  break;
	case 5:
	  System.out.println("val = 5");
	  break;
	default:
	  System.out.println("val > 5");
	}
      }
    }
#+END_SRC

Como se puede observar, el código es mucho más claro, tenemos una sola sentencia condicional, ~switch~, y esta, en base al valor que tenga la variable, entrará por un ~case~ o por otro y, en caso de que no coincida con ninguno, entrará por el ~default~.

Podemos observar también una sentencia que no habíamos visto antes, la sentencia ~break~, esta sentencia /rompe/ la ejecución del bloque en el que se encuentra, sería como ir a la llave de cierre, normalmente está desaconsejado su uso, pero en la sentencia ~switch~ es necesaria para cortar la ejecución donde nos interese, ya que, a diferencia de con las estructuras ~if-else~, que están englobadas con llaves que nos hacen de corte, los ~case~ y ~default~ son etiquetas, y no delimitan código, lo marcan. Veamos que pasa si no ponemos la sentencia ~break~ en un ~switch~.
* Bucles
* Métodos
* Objetos

